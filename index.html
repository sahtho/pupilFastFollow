
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Hooke's Law Simulation test</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
    }
    canvas {
      border: 1px solid #000;
      background: #f0f0f0;
    }
    .controls {
      margin-top: 20px;
      font-size: 22px;
    }
    label, p {
      font-size: 24px;
    }
    input[type="number"] {
      width: 80px;
      font-size: 22px;
      text-align: center;
    }
  </style>
</head>
<body>
  <h2>Hooke's Law Simulation</h2>
  <canvas id="canvas" width="800" height="300"></canvas>
  <div class="controls">
    <label>Spring Constant (k): 
      <input type="range" id="kInput" min="1" max="50" value="10">
      <input type="number" id="kNumber" min="1" max="50" value="10">
      <span id="kValue">10</span> N/m
    </label>
    <br><br>
    <label>Force (F): 
      <input type="range" id="fInput" min="-100" max="100" value="0">
      <input type="number" id="fNumber" min="-100" max="100" value="0">
      <span id="fValue">0</span> N
    </label>
    <br><br>
    <p>Displacement (x): <span id="xValue">0.00</span> m</p>
    <p>พัฒนาระบบโดย นายสราวุฒิ สุริยา</p>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const kInput = document.getElementById("kInput");
    const kNumber = document.getElementById("kNumber");
    const fInput = document.getElementById("fInput");
    const fNumber = document.getElementById("fNumber");
    const kValue = document.getElementById("kValue");
    const fValue = document.getElementById("fValue");
    const xValue = document.getElementById("xValue");

    let k = parseFloat(kInput.value);
    let F = parseFloat(fInput.value);

    const springStartX = 50;
    const springY = canvas.height / 2;
    const springRestLength = canvas.width / 2;

    function syncInputs(rangeInput, numberInput, valueDisplay, callback) {
      function updateValues(value) {
        rangeInput.value = value;
        numberInput.value = value;
        valueDisplay.textContent = value;
        callback();
      }
      rangeInput.addEventListener("input", () => updateValues(rangeInput.value));
      numberInput.addEventListener("input", () => updateValues(numberInput.value));
    }

    syncInputs(kInput, kNumber, kValue, () => {
      k = parseFloat(kInput.value);
      update();
    });

    syncInputs(fInput, fNumber, fValue, () => {
      F = parseFloat(fInput.value);
      update();
    });

    function drawSpring(startX, y, length, amplitude = 20, coils = 10) {
      ctx.beginPath();
      ctx.moveTo(startX, y);
      for (let i = 0; i < coils; i++) {
        const dx = length / coils;
        const direction = i % 2 === 0 ? 1 : -1;
        ctx.lineTo(startX + dx * (i + 0.5), y + direction * amplitude);
        ctx.lineTo(startX + dx * (i + 1), y);
      }
      ctx.strokeStyle = "blue";
      ctx.lineWidth = 6;
      ctx.stroke();
    }

    function drawArrow(fromX, toX, y, color, width = 4, headSize = 10) {
      const headLength = headSize;
      const angle = Math.atan2(0, toX - fromX);

      ctx.beginPath();
      ctx.moveTo(fromX, y);
      ctx.lineTo(toX, y);
      ctx.strokeStyle = color;
      ctx.lineWidth = width;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(toX, y);
      ctx.lineTo(toX - headLength * Math.cos(angle - Math.PI / 6), y - headLength * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - headLength * Math.cos(angle + Math.PI / 6), y - headLength * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    function update() {
      const x = F / k;
      const scale = 20;
      const displacementPx = x * scale;
      xValue.textContent = x.toFixed(2);

      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw anchor point
      ctx.beginPath();
      ctx.arc(springStartX, springY, 14, 0, 2 * Math.PI);
      ctx.fillStyle = "black";
      ctx.fill();

      const equilibriumX = springStartX + springRestLength;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.moveTo(equilibriumX, 0);
      ctx.lineTo(equilibriumX, canvas.height);
      ctx.strokeStyle = "green";
      ctx.lineWidth = 6;
      ctx.stroke();
      ctx.setLineDash([]);

      const currentLength = springRestLength + displacementPx;
      drawSpring(springStartX, springY, currentLength);

      if (displacementPx > 0) {
        drawArrow(equilibriumX, equilibriumX + displacementPx, springY - 40, "black", 5, 14);
        ctx.fillStyle = "black";
        ctx.font = "30px Arial";
        ctx.fillText(`${F.toFixed(0)} N`, equilibriumX + displacementPx / 2 - 20, springY - 60);
      } else if (displacementPx < 0) {
        drawArrow(equilibriumX, equilibriumX + displacementPx, springY + 40, "red", 5, 14);
        ctx.fillStyle = "red";
        ctx.font = "30px Arial";
        ctx.fillText(`${F.toFixed(0)} N`, equilibriumX + displacementPx / 2 - 20, springY + 75);
      }
    }

    update();
  </script>
</body>
</html>
